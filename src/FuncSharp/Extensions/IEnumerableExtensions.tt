<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="../Helpers.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
    public static class IEnumerableExtensions
    {
        /// <summary>
        /// Returns values of the nonempty options.
        /// </summary>
        public static IEnumerable<T> Flatten<T>(this IEnumerable<IOption<T>> source)
        {
            return source.SelectMany(o => o.ToList());
        }

        /// <summary>
        /// Returns first value or an empty option. 
        /// </summary>
        public static IOption<T> FirstOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            var data = source.Where(predicate ?? (t => true)).Take(1).ToList();
            if (data.Count == 0)
            {
                return Option.Empty<T>();
            }
            return Option.Valued(data.First());
        }

        /// <summary>
        /// Returns last value or an empty option. 
        /// </summary>
        public static IOption<T> LastOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            return source.Reverse().FirstOption(predicate);
        }

        /// <summary>
        /// Returns the only value if the source contains just one value, otherwise an empty option.
        /// </summary>
        public static IOption<T> SingleOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            var data = source.Where(predicate ?? (t => true)).Take(2).ToList();
            if (data.Count == 2)
            {
                return Option.Empty<T>();
            }
            return data.FirstOption();
        }

        /// <summary>
        /// Orders the values using the specified less function in the specified order.
        /// </summary>
        public static IEnumerable<T> Order<T>(this IEnumerable<T> values, Func<T, T, bool> less, Ordering ordering = Ordering.Ascending)
        {
            var comparer = new Comparer<T>(less, ordering);
            return values.OrderBy(v => v, comparer);
        }

        /// <summary>
        /// Aggregates the exceptions into an AggregateException. If there is a single exception, returns it directly.
        /// </summary>
        public static IOption<Exception> Aggregate(this IEnumerable<Exception> source)
        {
            var exceptions = source.ToList();
            switch (exceptions.Count)
            {
                case 0: return Option<Exception>.Empty;
                case 1: return Option.Valued(exceptions[0]);
                default: return Option.Valued(new AggregateException(exceptions));
            }
        }
        <#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube and aggregates the values in case of conflicting positions.
        /// </summary>
        public static <#= DataCubeType(i, valueType: "TResult") #> ToDataCube<T, <#= Types(i, name: "P") #>, TValue, TResult>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value,
            Func<TValue, TResult> initialization,
            Func<TResult, TValue, TResult> aggregation)
        {
            var dataCube = new <#= DataCubeType(i, valueType: "TResult") #>();
            foreach (var v in source)
            {
                dataCube.SetOrElseUpdate<TValue>(<#= List(i, x => "p" + x + "(v)") #>, value(v), initialization, aggregation);
            }
            return dataCube;
        }
<#  } #>

<#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube.
        /// </summary>
        public static <#= DataCubeType(i) #> ToDataCube<T, <#= Types(i, name: "P") #>, TValue>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value)
        {
            return ToDataCube<T, <#= Types(i, name: "P") #>, TValue, TValue>(source, <#= List(i, x => "p" + x) #>, value, a => a, aggregation: (a, b) => throw new ArgumentException("An item with the same key has already been added."));
        }
<#  } #>
<#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube, in case of collisions, it aggregates the values to a collection.
        /// </summary>
        public static <#= DataCubeType(i, valueType: "IEnumerable<TValue>") #> ToCollectionDataCube<T, <#= Types(i, name: "P") #>, TValue>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value)
        {
            return ToDataCube<T, <#= Types(i, name: "P") #>, TValue, IEnumerable<TValue>>(source, <#= List(i, x => "p" + x) #>, value, a => Enumerable.Repeat(a, 1), (a, b) => a.Concat(new [] { b }));
        }
<#  } #>

<#  for (var i = 1; i < MaxArity(); i++) { #>

        /// <summary>
        /// For each partition (collection of n-th coproduct elements), invokes the specified function.
        /// </summary>
        public static void PartitionMatch<#= TypeBracket(i) #>(
            this IEnumerable<<#= CoproductType(i) #>> source,
<#= Lines(i, x => Indent(12) + "Action<IReadOnlyList<" + Type(x) + ">> f" + x, separator: ",") #>)
        {
<#= Lines(i, x => Indent(12) + "var list" + x + " = new List<T" + x + ">();") #>

            foreach (var c in source)
            {
                c.Match(
<#= Lines(i, x => Indent(20) + "c" + x + " => list" + x + ".Add(c" + x + ")", separator: ",") #>
                );
            }

<#= Lines(i, x => Indent(12) + "f" + x + "(list" + x + ");") #>
        }
<#  } #>
<#  for (var i = 1; i < MaxArity(); i++) { #>

        /// <summary>
        /// For each partition (collection of n-th coproduct elements), invokes the specified function, aggregates results and returns them.
        /// </summary>
        public static IReadOnlyList<TResult> PartitionMatch<<#= FuncTypes(i) #>>(
            this IEnumerable<<#= CoproductType(i) #>> source,
<#= Lines(i, x => Indent(12) + "Func<IReadOnlyList<" + Type(x) + ">, IEnumerable<TResult>> f" + x, separator: ",") #>)
        {
            var result = new List<TResult>();

            source.PartitionMatch(
<#= Lines(i, x => Indent(16) + "c" + x + " => result.AddRange(f" + x + "(c" + x + "))", separator: ",") #>
            );

            return result;
        }
<#  } #>
    }
}