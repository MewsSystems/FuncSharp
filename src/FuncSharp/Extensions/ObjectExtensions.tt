<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="../Helpers.ttinclude" #>
using System;
using System.Diagnostics;
using System.Diagnostics.Contracts;
using System.Threading.Tasks;

namespace FuncSharp
{
    public static class ObjectExtensions
    {
        [Pure]
        public static INonEmptyEnumerable<T> ToEnumerable<T>(this T value)
        {
            return NonEmptyEnumerable.Create(value);
        }

        [Pure]
        public static bool SafeEquals<T>(this T t, T other)
        {
            return Equals(t, other);
        }

        [Pure]
        public static bool SafeNotEquals<T>(this T t, T other)
        {
            return !t.SafeEquals(other);
        }

        [Pure]
        public static bool SafeEquals<T>(this T t, T? other)
            where T : struct
        {
            return ((T?)t).SafeEquals(other);
        }

        [Pure]
        public static bool SafeEquals<T>(this T? t, T other)
            where T : struct
        {
            return t.SafeEquals((T?)other);
        }

        [Pure]
        [Obsolete("Use Match instead.", error: true)]
        public static void MatchRef<A>(this Option<A> a, Action<A> action = null, Action<Unit> otherwise = null)
        {
            throw new NotImplementedException();
        }

        [DebuggerStepThrough]
        [Pure]
        public static void MatchRef<A>(this A a, Action<A> action = null, Action<Unit> otherwise = null)
            where A : class
        {
            if (a is not null)
            {
                if (action is not null)
                {
                    action(a);
                }
            }
            else if (otherwise is not null)
            {
                otherwise(Unit.Value);
            }
        }

        [DebuggerStepThrough]
        [Pure]
        public static bool MatchRef<A>(this A a, Func<A, bool> func)
            where A : class
        {
            return a is not null && func(a);
        }

        [Obsolete("Use Match instead.", error: true)]
        public static B MatchRef<A, B>(this Option<A> a, Func<A, B> func, Func<Unit, B> otherwise)
        {
            throw new NotImplementedException();
        }

        [DebuggerStepThrough]
        [Pure]
        public static B MatchRef<A, B>(this A a, Func<A, B> func, Func<Unit, B> otherwise)
            where A : class
        {
            if (a is not null)
            {
                return func(a);
            }
            return otherwise(Unit.Value);
        }

        [DebuggerStepThrough]
        [Pure]
        public static async Task<B> MatchRefAsync<A, B>(this A a, Func<A, Task<B>> func, Func<Unit, Task<B>> otherwise)
            where A : class
        {
            if (a is not null)
            {
                return await func(a);
            }
            return await otherwise(Unit.Value);
        }

        [Obsolete("Use Map instead.", error: true)]
        [Pure]
        public static B MapRef<A, B>(this Option<A> a, Func<A, B> func)
        {
            throw new NotImplementedException();
        }

        [DebuggerStepThrough]
        [Pure]
        public static B MapRef<A, B>(this A a, Func<A, B> func)
            where A : class
            where B : class
        {
            if (a is not null)
            {
                return func(a);
            }

            return null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static async Task<B> MapRefAsync<A, B>(this A a, Func<A, Task<B>> func)
            where A : class
            where B : class
        {
            if (a is not null)
            {
                return await func(a);
            }
            return default;
        }

        [DebuggerStepThrough]
        [Pure]
         public static B? MapRefToVal<A, B>(this A a, Func<A, B> func)
            where A : class
            where B : struct
        {
            return a is not null
                ? func(a)
                : null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static B? MapRefToVal<A, B>(this A a, Func<A, B?> func)
            where A : class
            where B : struct
        {
            return a is not null
                ? func(a)
                : null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static void MatchVal<A>(this A? a, Action<A> action = null, Action<Unit> otherwise = null)
            where A : struct
        {
            if (a is not null)
            {
                if (action is not null)
                {
                    action(a.Value);
                }
            }
            else if (otherwise is not null)
            {
                otherwise(Unit.Value);
            }
        }

        [DebuggerStepThrough]
        [Pure]
        public static bool MatchVal<A>(this A? a, Func<A, bool> func)
            where A : struct
        {
            return a is {} value && func(value);
        }

        [DebuggerStepThrough]
        [Pure]
        public static B MatchVal<A, B>(this A? a, Func<A, B> func, Func<Unit, B> otherwise)
            where A : struct
        {
            return a is {} value
                ? func(value)
                : otherwise(Unit.Value);
        }

        [DebuggerStepThrough]
        [Pure]
        public static B? MapVal<A, B>(this A? a, Func<A, B> func)
            where A : struct
            where B : struct
        {
            return a is {} value
                ? func(value)
                : null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static B? MapVal<A, B>(this A? a, Func<A, B?> func)
            where A : struct
            where B : struct
        {
            return a is {} value
                ? func(value)
                : null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static B MapValToRef<A, B>(this A? a, Func<A, B> func)
            where A : struct
            where B : class
        {
            return a is {} value
                ? func(value)
                : null;
        }

        [DebuggerStepThrough]
        [Pure]
        public static async Task<B> MapValToRefAsync<A, B>(this A? a, Func<A, Task<B>> func)
            where A : struct
            where B : class
        {
            if (a is not null)
            {
                return await func(a.Value);
            }
            return default;
        }

        /// <summary>
        /// Casts the specified object to the given type.
        /// </summary>
        [Pure]
        public static Option<A> As<A>(this object o)
            where A : class
        {
            return (o as A).ToOption();
        }

        /// <summary>
        /// Returns string representation of the object. If the object is null, return the optionally specified null text.
        /// </summary>
        [Pure]
        public static string SafeToString(this object o, string nullText = "null")
        {
            if (o == null)
            {
                return nullText;
            }
            return o.ToString();
        }

        /// <summary>
        /// Turns the specified value into an option.
        /// </summary>
        [Pure]
        public static Option<A> ToOption<A>(this A value)
        {
            return Option.Create(value);
        }

        /// <summary>
        /// Turns the specified value into a successful try.
        /// </summary>
        [Pure]
        public static Try<A, E> ToTry<A, E>(this A value)
        {
            return Try.Success<A, E>(value);
        }

        /// <summary>
        /// Turns the specified error into a try.
        /// </summary>
        [Pure]
        public static Try<A, E> ToTry<A, E>(this E e)
        {
            return Try.Error<A, E>(e);
        }

<# for (var i = 1; i < MaxArity(); i++) { #>
        /// <summary>
        /// Creates a new <#= i #>-dimensional coproduct as a result of type match. The specified value will be on the first place 
        /// whose type matches type of the value. If none of the types matches type of the value, returns result of the fallback 
        /// function. In case when the fallback is null, throws an exception (optionally created by the otherwise function).
        /// </summary>
        [Pure]
        public static <#= CoproductImplType(i) #> AsCoproduct<#= TypeBracket(i) #>(this object value, Func<object, <#= CoproductImplType(i) #>> fallback = null, Func<Unit, Exception> otherwise = null)
        {
            switch (value) {
<#= Lines(i, j => Indent(16) + "case " + Type(j) + " " + Value(j) + ": return Coproduct" + i + ".Create" + GetOrdinal(j) + TypeBracket(i) + "(" + Value(j) + ");") #>
            }

            if (fallback != null)
            {
                return fallback(value);
            }
            if (otherwise != null)
            {
                throw otherwise(Unit.Value);
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified types.");
        }

        /// <summary>
        /// Creates a new <#= i #>-dimensional coproduct as a result of value match against the parameters. The specified value will
        /// be on the first place whose corresponding parameter equals the value. If none of the parameters matches the value, 
        /// returns result of the fallback function. In case when the fallback is null, throws an exception (optionally created by 
        /// the otherwise function).
        /// </summary>
        [Pure]
        public static <#= CoproductImplType(i) #> AsCoproduct<#= TypeBracket(i) #>(this object value, <#= Parameters(i) #>, Func<object, <#= CoproductImplType(i) #>> fallback = null, Func<Unit, Exception> otherwise = null)
        {
<#     for (var j = 1; j <= i; j++) { #>
            if (Equals(value, <#= Value(j) #>))
            {
                return Coproduct<#= i #>.Create<#= GetOrdinal(j) #><#= TypeBracket(i) #>((<#= Type(j) #>)value);
            }
<#     } #>
            if (fallback != null)
            {
                return fallback(value);
            }
            if (otherwise != null)
            {
                throw otherwise(Unit.Value);
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified values.");
        }

<#     if (i + 1 < MaxArity()) { #>
<#         var safeTypeBracket = "<" + Types(i, appendSeparator: true) + "object>"; #>
        /// <summary>
        /// Creates a new <#= i + 1 #>-dimensional coproduct as a result of type match. The specified value will be on the first place 
        /// whose type matches type of the value. If none of the types matches type of the value, then the value will be placed in 
        /// the last place.
        /// </summary>
        [Pure]
        public static <#= "Coproduct" + (i + 1) + safeTypeBracket #> AsSafeCoproduct<#= TypeBracket(i) #>(this object value)
        {
            return value.AsCoproduct(v => Coproduct<#= i + 1 #>.Create<#= GetOrdinal(i + 1) #><#= safeTypeBracket #>(v));
        }

        /// <summary>
        /// Creates a new <#= i + 1 #>-dimensional coproduct as a result of value match against the parameters. The specified value will
        /// be on the first place whose corresponding parameter equals the value. If none of the parameters equals the value, then 
        /// the value will be placed in the last place.
        /// </summary>
        [Pure]
        public static <#= "Coproduct" + (i + 1) + safeTypeBracket #> AsSafeCoproduct<#= TypeBracket(i) #>(this object value, <#= Parameters(i) #>)
        {
            return value.AsCoproduct(<#= Values(i) #>, null, v => Coproduct<#= i + 1 #>.Create<#= GetOrdinal(i + 1) #><#= safeTypeBracket #>(v));
        }

        /// <summary>
        /// Matches the value with the specified parameters and returns result of the corresponding function.
        /// </summary>
        [Pure]
        public static TResult Match<T, TResult>(
            this T value,
<#= Lines(i, j => Indent(12) + "T " + Value(j) + ", Func<T, TResult> f" + j, separator: ",") #>,
            Func<T, TResult> otherwise = null)
        {
<#     for (var j = 1; j <= i; j++) { #>
            if (Equals(value, <#= Value(j) #>))
            {
                return f<#= j #>(value);
            }
<#     } #>
            if (otherwise != null)
            {
                return otherwise(value);
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified values.");
        }

        [Pure]
        public static async Task<TResult> MatchAsync<T, TResult>(
            this T value,
<#= Lines(i, j => Indent(12) + "T " + Value(j) + ", Func<T, Task<TResult>> f" + j, separator: ",") #>,
            Func<T, Task<TResult>> otherwise = null)
        {
<#     for (var j = 1; j <= i; j++) { #>
            if (Equals(value, <#= Value(j) #>))
            {
                return await f<#= j #>(value);
            }
<#     } #>
            if (otherwise != null)
            {
                return await otherwise(value);
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified values.");
        }

        /// <summary>
        /// Matches the value with the specified parameters and executes the corresponding function.
        /// </summary>
        [Pure]
        public static void Match<T>(
            this T value,
<#= Lines(i, j => Indent(12) + "T " + Value(j) + ", Action<T> f" + j, separator: ",") #>,
            Action<T> otherwise = null)
        {
<#     for (var j = 1; j <= i; j++) { #>
            if (Equals(value, <#= Value(j) #>))
            {
                f<#= j #>(value);
                return;
            }
<#     } #>
            if (otherwise != null)
            {
                otherwise(value);
                return;
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified values.");
        }

        [Pure]
        public static async Task MatchAsync<T>(
            this T value,
<#= Lines(i, j => Indent(12) + "T " + Value(j) + ", Func<T,Task> f" + j, separator: ",") #>,
            Func<T, Task> otherwise = null)
        {
<#     for (var j = 1; j <= i; j++) { #>
            if (Equals(value, <#= Value(j) #>))
            {
                await f<#= j #>(value);
                return;
            }
<#     } #>
            if (otherwise != null)
            {
                await otherwise(value);
                return;
            }
            throw new ArgumentException("The value " + value.SafeToString() + " does not match any of the <#= i #> specified values.");
        }

<#     } #>
<# } #>
    }
}