<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="../Helpers.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace FuncSharp
{
    public static class IEnumerableExtensions
    {
        #region Generic

        /// <summary>
        /// Returns a ToList() juts of type IReadOnlyList.
        /// </summary>
        public static IReadOnlyList<T> ToReadOnlyList<T>(this IEnumerable<T> e)
        {
            return e.ToList().AsReadOnly();
        }

        /// <summary>
        /// Returns the IEnumerable in case it is a ReadOnlyList or creates a new ReadOnlyList from it.
        /// </summary>
        [DebuggerStepThrough]
        public static IReadOnlyList<T> AsReadOnlyList<T>(this IEnumerable<T> source)
        {
            return source as IReadOnlyList<T> ?? source.ToList();
        }

        /// <summary>
        /// Returns the IEnumerable in case it is a List or creates a new List from it.
        /// </summary>
        [DebuggerStepThrough]
        public static List<T> AsList<T>(this IEnumerable<T> source)
        {
            return source as List<T> ?? source.ToList();
        }

        /// <summary>
        /// Returns all the items inside all the collections combined into 1 IEnumerable.
        /// </summary>
        public static IEnumerable<T> Flatten<T>(this IEnumerable<IEnumerable<T>> e)
        {
            return e.SelectMany(i => i);
        }

        public static IEnumerable<T> Except<T>(this IEnumerable<T> e, params T[] excludedItems)
        {
            return e.Except(excludedItems.AsEnumerable());
        }

        public static IEnumerable<T> Except<T>(this IEnumerable<T> e, params IEnumerable<T>[] others)
        {
            return Enumerable.Except(e, others.Flatten());
        }

        public static IEnumerable<T> ExceptNulls<T>(this IEnumerable<T?> e)
            where T : struct
        {
            return e.Where(v => v.HasValue).Select(v => v.Value);
        }

        public static IEnumerable<T> ExceptNulls<T>(this IEnumerable<T> e)
            where T : class
        {
            return e.Where(v => v is not null);
        }

        public static bool NonEmpty<T>(this IEnumerable<T> e)
        {
            return e is not null && e.Any();
        }

        public static bool IsEmpty<T>(this IEnumerable<T> e)
        {
            return !e.NonEmpty();
        }

        public static bool IsMultiple<T>(this IEnumerable<T> e)
        {
            return e is not null && e.Take(2).Count().SafeEquals(2);
        }

        public static bool IsSingle<T>(this IEnumerable<T> e)
        {
            return e is not null && e.Take(2).Count().SafeEquals(1);
        }

        public static T Second<T>(this IEnumerable<T> e)
        {
            return e.ElementAt(1);
        }

        public static T Third<T>(this IEnumerable<T> e)
        {
            return e.ElementAt(2);
        }

        public static T Fourth<T>(this IEnumerable<T> e)
        {
            return e.ElementAt(3);
        }

        public static T Fifth<T>(this IEnumerable<T> e)
        {
            return e.ElementAt(4);
        }

        public static IEnumerable<T> Concat<T>(this IEnumerable<T> first, params T[] items)
        {
            return Enumerable.Concat(first, items);
        }

        public static IEnumerable<T> Concat<T>(this IEnumerable<T> first, params IEnumerable<T>[] others)
        {
            return Enumerable.Concat(first, others.Flatten());
        }

        public static IEnumerable<T> SafeConcat<T>(this IEnumerable<T> first, params T[] items)
        {
            return Enumerable.Concat(first ?? Enumerable.Empty<T>(), items);
        }

        public static IEnumerable<T> SafeConcat<T>(this IEnumerable<T> first, params IEnumerable<T>[] others)
        {
            return Enumerable.Concat(first ?? Enumerable.Empty<T>(), others.SelectMany(o => o ?? Enumerable.Empty<T>()));
        }

        /// <summary>
        /// Orders the values using the specified less function in the specified order.
        /// </summary>
        public static IEnumerable<T> Order<T>(this IEnumerable<T> values, Func<T, T, bool> less, Ordering ordering = Ordering.Ascending)
        {
            var comparer = new Comparer<T>(less, ordering);
            return values.OrderBy(v => v, comparer);
        }

        /// <summary>
        /// Aggregates the exceptions into an AggregateException. If there is a single exception, returns it directly.
        /// </summary>
        public static IOption<Exception> Aggregate(this IEnumerable<Exception> source)
        {
            var exceptions = source.ToList();
            switch (exceptions.Count)
            {
                case 0: return Option<Exception>.Empty;
                case 1: return Option.Valued(exceptions[0]);
                default: return Option.Valued(new AggregateException(exceptions));
            }
        }

        #endregion Generic

        #region Numeric

        public static PositiveInt Sum(this INonEmptyEnumerable<PositiveInt> values)
        {
            return PositiveInt.CreateUnsafe(values.Sum(v => v.Value));
        }

        public static NonPositiveInt Sum(this IEnumerable<NonPositiveInt> values)
        {
            return values.Aggregate(0.AsUnsafeNonPositive(), (a, b) => a + b);
        }

        public static NonNegativeInt Sum(this IEnumerable<NonNegativeInt> values)
        {
            return values.Aggregate(NonNegativeInt.Zero, (a, b) => a + b);
        }

        #endregion Numeric

        #region NonEmpty

        /// <summary>
        /// Returns a nonEmptyEnumerable in case the collection is nonempty. Otherwise returns empty option.
        /// </summary>
        [DebuggerStepThrough]
        public static IOption<INonEmptyEnumerable<T>> AsNonEmpty<T>(this IEnumerable<T> source)
        {
            if (source is null)
            {
                return Option.Empty<INonEmptyEnumerable<T>>();
            }
            return NonEmptyEnumerable.Create(source);
        }

        /// <summary>
        /// Returns the nonEmptyEnumerable typed as IReadOnlyList.
        /// </summary>
        [DebuggerStepThrough]
        public static IReadOnlyList<T> AsReadOnly<T>(this INonEmptyEnumerable<T> source)
        {
            return source;
        }

        public static INonEmptyEnumerable<V> SelectMany<T, V>(this INonEmptyEnumerable<T> source, Func<T, INonEmptyEnumerable<V>> selector)
        {
            return NonEmptyEnumerable.CreateFlat(source.Select(selector));
        }

        public static INonEmptyEnumerable<T> Flatten<T>(this INonEmptyEnumerable<INonEmptyEnumerable<T>> source)
        {
            return NonEmptyEnumerable.CreateFlat(source);
        }

        public static INonEmptyEnumerable<T> Concat<T>(this T e, params IEnumerable<T>[] others)
        {
            return NonEmptyEnumerable.Create(e, others.Flatten());
        }

        public static INonEmptyEnumerable<T> Concat<T>(this INonEmptyEnumerable<T> source, params T[] items)
        {
            return source.Concat(items.AsEnumerable());
        }

        public static INonEmptyEnumerable<T> Concat<T>(this INonEmptyEnumerable<T> source, params IEnumerable<T>[] items)
        {
            return NonEmptyEnumerable.Create(source.Head, source.Tail.Concat(items));
        }

        #endregion NonEmpty

        #region Options

        /// <summary>
        /// Returns values of the nonempty options.
        /// </summary>
        public static IEnumerable<T> Flatten<T>(this IEnumerable<IOption<T>> source)
        {
            return source.SelectMany(o => o.ToList());
        }

        public static IOption<TValue> SafeMax<T, TValue>(this IEnumerable<T> source, Func<T, TValue> selector)
        {
            return source.AsNonEmpty().Map(s => s.Max(selector));
        }

        public static IOption<TValue> SafeMin<T, TValue>(this IEnumerable<T> source, Func<T, TValue> selector)
        {
            return source.AsNonEmpty().Map(s => s.Min(selector));
        }

        /// <summary>
        /// Returns first value or an empty option.
        /// </summary>
        public static IOption<T> FirstOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            var data = source.Where(predicate ?? (t => true)).Take(1).ToList();
            if (data.Count == 0)
            {
                return Option.Empty<T>();
            }
            return Option.Valued(data.First());
        }

        /// <summary>
        /// Returns last value or an empty option.
        /// </summary>
        public static IOption<T> LastOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            return source.Reverse().FirstOption(predicate);
        }

        /// <summary>
        /// Returns the only value if the source contains just one value, otherwise an empty option.
        /// </summary>
        public static IOption<T> SingleOption<T>(this IEnumerable<T> source, Func<T, bool> predicate = null)
        {
            var data = source.Where(predicate ?? (t => true)).Take(2).ToList();
            if (data.Count == 2)
            {
                return Option.Empty<T>();
            }
            return data.FirstOption();
        }

        #endregion Options

        #region DataCubes
<#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube and aggregates the values in case of conflicting positions.
        /// </summary>
        public static <#= DataCubeType(i, valueType: "TResult") #> ToDataCube<T, <#= Types(i, name: "P") #>, TValue, TResult>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value,
            Func<TValue, TResult> initialization,
            Func<TResult, TValue, TResult> aggregation)
        {
            var dataCube = new <#= DataCubeType(i, valueType: "TResult") #>();
            foreach (var v in source)
            {
                dataCube.SetOrElseUpdate<TValue>(<#= List(i, x => "p" + x + "(v)") #>, value(v), initialization, aggregation);
            }
            return dataCube;
        }
<#  } #>

<#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube.
        /// </summary>
        public static <#= DataCubeType(i) #> ToDataCube<T, <#= Types(i, name: "P") #>, TValue>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value)
        {
            return ToDataCube<T, <#= Types(i, name: "P") #>, TValue, TValue>(source, <#= List(i, x => "p" + x) #>, value, a => a, aggregation: (a, b) => throw new ArgumentException("An item with the same key has already been added."));
        }
<#  } #>
<#  for (var i = 1; i <= MaxCubeArity(); i++) { #>

        /// <summary>
        /// Converts the source to a new <#= i #>-dimensional data cube, in case of collisions, it aggregates the values to a collection.
        /// </summary>
        public static <#= DataCubeType(i, valueType: "IEnumerable<TValue>") #> ToCollectionDataCube<T, <#= Types(i, name: "P") #>, TValue>(
            this IEnumerable<T> source,
<#= Lines(i, x => Indent(12) + "Func<T, P" + x + "> p" + x, separator: ",") #>,
            Func<T, TValue> value)
        {
            return ToDataCube<T, <#= Types(i, name: "P") #>, TValue, IEnumerable<TValue>>(source, <#= List(i, x => "p" + x) #>, value, a => Enumerable.Repeat(a, 1), (a, b) => a.Concat(new [] { b }));
        }
<#  } #>

        #endregion DataCubes

        #region PartitionMatch

<#  for (var i = 1; i < MaxArity(); i++) { #>

        /// <summary>
        /// For each partition (collection of n-th coproduct elements), invokes the specified function.
        /// </summary>
        public static void PartitionMatch<#= TypeBracket(i) #>(
            this IEnumerable<<#= CoproductType(i) #>> source,
<#= Lines(i, x => Indent(12) + "Action<IReadOnlyList<" + Type(x) + ">> f" + x, separator: ",") #>)
        {
<#= Lines(i, x => Indent(12) + "var list" + x + " = new List<T" + x + ">();") #>

            foreach (var c in source)
            {
                c.Match(
<#= Lines(i, x => Indent(20) + "c" + x + " => list" + x + ".Add(c" + x + ")", separator: ",") #>
                );
            }

<#= Lines(i, x => Indent(12) + "f" + x + "(list" + x + ");") #>
        }

        /// <summary>
        /// For each partition (collection of n-th coproduct elements), invokes the specified function, aggregates results and returns them.
        /// </summary>
        public static IReadOnlyList<TResult> PartitionMatch<<#= FuncTypes(i) #>>(
            this IEnumerable<<#= CoproductType(i) #>> source,
<#= Lines(i, x => Indent(12) + "Func<IReadOnlyList<" + Type(x) + ">, IEnumerable<TResult>> f" + x, separator: ",") #>)
        {
            var result = new List<TResult>();

            source.PartitionMatch(
<#= Lines(i, x => Indent(16) + "c" + x + " => result.AddRange(f" + x + "(c" + x + "))", separator: ",") #>
            );

            return result;
        }
<#  } #>

        #endregion PartitionMatch

    }
}