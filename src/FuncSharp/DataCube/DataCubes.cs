using System;
using System.Collections.Generic;
using System.Linq;

namespace FuncSharp
{
    /// <summary>
    /// A 0-dimensional data cube.
    /// </summary>
    public class DataCube0<TValue> : DataCube<Position0, TValue>
    {
        /// <summary>
        /// Creates an empty 0-dimensional data cube. 
        /// </summary>
        public DataCube0()
        {
        }

        /// <summary>
        /// The only value in the cube.
        /// </summary>
        public Option<TValue> Value 
        { 
            get { return Get(); }
        }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains()
        {
            return Contains(Position0.Create());
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get()
        {
            return Get(Position0.Create());
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position0.Create(), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position0 position, TValue value)
        {
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(TValue value)
        {
            return Set(Position0.Create(), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position0.Create(), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position0.Create(), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position0.Create(), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<TValue> a)
        {
            ForEach((p, v) => a(v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<TValue, T> f)
        {
            return Select((p, v) => f(v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube0<TValue> Where(Func<Position0, TValue, bool> predicate)
        {
            return Where<DataCube0<TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position0, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position0, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }
    }

    /// <summary>
    /// A 1-dimensional data cube.
    /// </summary>
    public class DataCube1<P1, TValue> : DataCube<Position1<P1>, TValue>
    {
        /// <summary>
        /// Creates an empty 1-dimensional data cube. 
        /// </summary>
        public DataCube1()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1)
        {
            return Contains(Position1.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1)
        {
            return Get(Position1.Create(p1));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position1.Create(p1), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position1<P1> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, TValue value)
        {
            return Set(Position1.Create(p1), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position1.Create(p1), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position1.Create(p1), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position1.Create(p1), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube1<P1, TValue> Where(Func<Position1<P1>, TValue, bool> predicate)
        {
            return Where<DataCube1<P1, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position1<P1>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position1<P1>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position1<P1>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position1<P1>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 1-dimensional cube into a 0-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube0<TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 0-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube0<TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube0<TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube0<TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }
    }

    /// <summary>
    /// A 2-dimensional data cube.
    /// </summary>
    public class DataCube2<P1, P2, TValue> : DataCube<Position2<P1, P2>, TValue>
    {
        /// <summary>
        /// Creates an empty 2-dimensional data cube. 
        /// </summary>
        public DataCube2()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
            Domain2Values = new HashSet<ValueTuple<P2>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        private HashSet<ValueTuple<P2>> Domain2Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2)
        {
            return Contains(Position2.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1, P2 p2)
        {
            return Get(Position2.Create(p1, p2));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position2.Create(p1, p2), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position2<P1, P2> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            AddDomain(Domain2Values, position.ProductValue2);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, TValue value)
        {
            return Set(Position2.Create(p1, p2), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, P2 p2, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position2.Create(p1, p2), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position2.Create(p1, p2), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, P2 p2, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position2.Create(p1, p2), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, p.ProductValue2, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, P2, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, p.ProductValue2, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, P2, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, p.ProductValue2, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube2<P1, P2, TValue> Where(Func<Position2<P1, P2>, TValue, bool> predicate)
        {
            return Where<DataCube2<P1, P2, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position2<P1, P2>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position2<P1, P2>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position2<P1, P2>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position2<P1, P2>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 2-dimensional cube into a 1-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube1<P2, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 1-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube1<P2, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube1<P2, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube1<P2, TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<Position2<P1, P2>, Position2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<Position2<P1, P2>, IEnumerable<Position2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 2-dimensional cube into a 1-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube1<P1, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 1-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube1<P1, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube1<P1, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue2, _ => new DataCube1<P1, TValue>());
                slice.Set(p.ExceptValue2, v);
            });
            return slices;
        }
    }

    /// <summary>
    /// A 3-dimensional data cube.
    /// </summary>
    public class DataCube3<P1, P2, P3, TValue> : DataCube<Position3<P1, P2, P3>, TValue>
    {
        /// <summary>
        /// Creates an empty 3-dimensional data cube. 
        /// </summary>
        public DataCube3()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
            Domain2Values = new HashSet<ValueTuple<P2>>();
            Domain3Values = new HashSet<ValueTuple<P3>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        private HashSet<ValueTuple<P2>> Domain2Values { get; }

        private HashSet<ValueTuple<P3>> Domain3Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3)
        {
            return Contains(Position3.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1, P2 p2, P3 p3)
        {
            return Get(Position3.Create(p1, p2, p3));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position3.Create(p1, p2, p3), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position3<P1, P2, P3> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            AddDomain(Domain2Values, position.ProductValue2);
            AddDomain(Domain3Values, position.ProductValue3);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, TValue value)
        {
            return Set(Position3.Create(p1, p2, p3), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, P2 p2, P3 p3, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position3.Create(p1, p2, p3), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position3.Create(p1, p2, p3), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, P2 p2, P3 p3, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position3.Create(p1, p2, p3), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, p.ProductValue2, p.ProductValue3, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, P2, P3, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, P2, P3, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube3<P1, P2, P3, TValue> Where(Func<Position3<P1, P2, P3>, TValue, bool> predicate)
        {
            return Where<DataCube3<P1, P2, P3, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position3<P1, P2, P3>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position3<P1, P2, P3>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position3<P1, P2, P3>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position3<P1, P2, P3>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube2<P2, P3, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 2-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube2<P2, P3, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube2<P2, P3, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube2<P2, P3, TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<Position3<P1, P2, P3>, Position2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<Position3<P1, P2, P3>, IEnumerable<Position2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube2<P1, P3, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 2-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube2<P1, P3, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube2<P1, P3, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue2, _ => new DataCube2<P1, P3, TValue>());
                slice.Set(p.ExceptValue2, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<Position3<P1, P2, P3>, Position3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<Position3<P1, P2, P3>, IEnumerable<Position3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 3-dimensional cube into a 2-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube2<P1, P2, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 2-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube2<P1, P2, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube2<P1, P2, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue3, _ => new DataCube2<P1, P2, TValue>());
                slice.Set(p.ExceptValue3, v);
            });
            return slices;
        }
    }

    /// <summary>
    /// A 4-dimensional data cube.
    /// </summary>
    public class DataCube4<P1, P2, P3, P4, TValue> : DataCube<Position4<P1, P2, P3, P4>, TValue>
    {
        /// <summary>
        /// Creates an empty 4-dimensional data cube. 
        /// </summary>
        public DataCube4()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
            Domain2Values = new HashSet<ValueTuple<P2>>();
            Domain3Values = new HashSet<ValueTuple<P3>>();
            Domain4Values = new HashSet<ValueTuple<P4>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the fourth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P4> Domain4
        {
            get { return Domain4Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        private HashSet<ValueTuple<P2>> Domain2Values { get; }

        private HashSet<ValueTuple<P3>> Domain3Values { get; }

        private HashSet<ValueTuple<P4>> Domain4Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Contains(Position4.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1, P2 p2, P3 p3, P4 p4)
        {
            return Get(Position4.Create(p1, p2, p3, p4));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, P4 p4, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position4.Create(p1, p2, p3, p4), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position4<P1, P2, P3, P4> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            AddDomain(Domain2Values, position.ProductValue2);
            AddDomain(Domain3Values, position.ProductValue3);
            AddDomain(Domain4Values, position.ProductValue4);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, P4 p4, TValue value)
        {
            return Set(Position4.Create(p1, p2, p3, p4), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, P2 p2, P3 p3, P4 p4, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position4.Create(p1, p2, p3, p4), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, P4 p4, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position4.Create(p1, p2, p3, p4), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, P2 p2, P3 p3, P4 p4, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position4.Create(p1, p2, p3, p4), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, P4, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, P2, P3, P4, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, P2, P3, P4, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube4<P1, P2, P3, P4, TValue> Where(Func<Position4<P1, P2, P3, P4>, TValue, bool> predicate)
        {
            return Where<DataCube4<P1, P2, P3, P4, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position4<P1, P2, P3, P4>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position4<P1, P2, P3, P4>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position4<P1, P2, P3, P4>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position4<P1, P2, P3, P4>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube3<P2, P3, P4, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 3-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube3<P2, P3, P4, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube3<P2, P3, P4, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube3<P2, P3, P4, TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<Position4<P1, P2, P3, P4>, Position2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<Position4<P1, P2, P3, P4>, IEnumerable<Position2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube3<P1, P3, P4, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 3-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube3<P1, P3, P4, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube3<P1, P3, P4, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue2, _ => new DataCube3<P1, P3, P4, TValue>());
                slice.Set(p.ExceptValue2, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<Position4<P1, P2, P3, P4>, Position3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<Position4<P1, P2, P3, P4>, IEnumerable<Position3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube3<P1, P2, P4, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 3-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube3<P1, P2, P4, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube3<P1, P2, P4, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue3, _ => new DataCube3<P1, P2, P4, TValue>());
                slice.Set(p.ExceptValue3, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> Transform<Q1, Q2, Q3, Q4>(Func<Position4<P1, P2, P3, P4>, Position4<Q1, Q2, Q3, Q4>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> MultiTransform<Q1, Q2, Q3, Q4>(Func<Position4<P1, P2, P3, P4>, IEnumerable<Position4<Q1, Q2, Q3, Q4>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 4-dimensional cube into a 3-dimensional cube by excluding the dimension 4.
        /// All values whose position differ just in dimension 4 (their positions without dimension 4 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 4.
        /// </summary>
        public DataCube3<P1, P2, P3, TValue> RollUpDimension4(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue4, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 4. The slices are 3-dimensional cubes without dimension 4 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P4, DataCube3<P1, P2, P3, TValue>> SliceDimension4()
        {
            var slices = new DataCube1<P4, DataCube3<P1, P2, P3, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue4, _ => new DataCube3<P1, P2, P3, TValue>());
                slice.Set(p.ExceptValue4, v);
            });
            return slices;
        }
    }

    /// <summary>
    /// A 5-dimensional data cube.
    /// </summary>
    public class DataCube5<P1, P2, P3, P4, P5, TValue> : DataCube<Position5<P1, P2, P3, P4, P5>, TValue>
    {
        /// <summary>
        /// Creates an empty 5-dimensional data cube. 
        /// </summary>
        public DataCube5()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
            Domain2Values = new HashSet<ValueTuple<P2>>();
            Domain3Values = new HashSet<ValueTuple<P3>>();
            Domain4Values = new HashSet<ValueTuple<P4>>();
            Domain5Values = new HashSet<ValueTuple<P5>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the fourth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P4> Domain4
        {
            get { return Domain4Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the fifth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P5> Domain5
        {
            get { return Domain5Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        private HashSet<ValueTuple<P2>> Domain2Values { get; }

        private HashSet<ValueTuple<P3>> Domain3Values { get; }

        private HashSet<ValueTuple<P4>> Domain4Values { get; }

        private HashSet<ValueTuple<P5>> Domain5Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
        {
            return Contains(Position5.Create(p1, p2, p3, p4, p5));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5)
        {
            return Get(Position5.Create(p1, p2, p3, p4, p5));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position5.Create(p1, p2, p3, p4, p5), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position5<P1, P2, P3, P4, P5> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            AddDomain(Domain2Values, position.ProductValue2);
            AddDomain(Domain3Values, position.ProductValue3);
            AddDomain(Domain4Values, position.ProductValue4);
            AddDomain(Domain5Values, position.ProductValue5);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, TValue value)
        {
            return Set(Position5.Create(p1, p2, p3, p4, p5), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position5.Create(p1, p2, p3, p4, p5), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position5.Create(p1, p2, p3, p4, p5), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position5.Create(p1, p2, p3, p4, p5), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, P4, P5, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, P2, P3, P4, P5, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, P2, P3, P4, P5, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube5<P1, P2, P3, P4, P5, TValue> Where(Func<Position5<P1, P2, P3, P4, P5>, TValue, bool> predicate)
        {
            return Where<DataCube5<P1, P2, P3, P4, P5, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position5<P1, P2, P3, P4, P5>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position5<P1, P2, P3, P4, P5>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 5-dimensional cube into a 4-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube4<P2, P3, P4, P5, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 4-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube4<P2, P3, P4, P5, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube4<P2, P3, P4, P5, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube4<P2, P3, P4, P5, TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<Position5<P1, P2, P3, P4, P5>, Position2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 5-dimensional cube into a 4-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube4<P1, P3, P4, P5, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 4-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube4<P1, P3, P4, P5, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube4<P1, P3, P4, P5, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue2, _ => new DataCube4<P1, P3, P4, P5, TValue>());
                slice.Set(p.ExceptValue2, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<Position5<P1, P2, P3, P4, P5>, Position3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 5-dimensional cube into a 4-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube4<P1, P2, P4, P5, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 4-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube4<P1, P2, P4, P5, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube4<P1, P2, P4, P5, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue3, _ => new DataCube4<P1, P2, P4, P5, TValue>());
                slice.Set(p.ExceptValue3, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> Transform<Q1, Q2, Q3, Q4>(Func<Position5<P1, P2, P3, P4, P5>, Position4<Q1, Q2, Q3, Q4>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> MultiTransform<Q1, Q2, Q3, Q4>(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position4<Q1, Q2, Q3, Q4>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 5-dimensional cube into a 4-dimensional cube by excluding the dimension 4.
        /// All values whose position differ just in dimension 4 (their positions without dimension 4 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 4.
        /// </summary>
        public DataCube4<P1, P2, P3, P5, TValue> RollUpDimension4(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue4, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 4. The slices are 4-dimensional cubes without dimension 4 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P4, DataCube4<P1, P2, P3, P5, TValue>> SliceDimension4()
        {
            var slices = new DataCube1<P4, DataCube4<P1, P2, P3, P5, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue4, _ => new DataCube4<P1, P2, P3, P5, TValue>());
                slice.Set(p.ExceptValue4, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube5<Q1, Q2, Q3, Q4, Q5, TValue> Transform<Q1, Q2, Q3, Q4, Q5>(Func<Position5<P1, P2, P3, P4, P5>, Position5<Q1, Q2, Q3, Q4, Q5>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position5<Q1, Q2, Q3, Q4, Q5>, DataCube5<Q1, Q2, Q3, Q4, Q5, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube5<Q1, Q2, Q3, Q4, Q5, TValue> MultiTransform<Q1, Q2, Q3, Q4, Q5>(Func<Position5<P1, P2, P3, P4, P5>, IEnumerable<Position5<Q1, Q2, Q3, Q4, Q5>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position5<Q1, Q2, Q3, Q4, Q5>, DataCube5<Q1, Q2, Q3, Q4, Q5, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 5-dimensional cube into a 4-dimensional cube by excluding the dimension 5.
        /// All values whose position differ just in dimension 5 (their positions without dimension 5 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 5.
        /// </summary>
        public DataCube4<P1, P2, P3, P4, TValue> RollUpDimension5(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue5, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 5. The slices are 4-dimensional cubes without dimension 5 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P5, DataCube4<P1, P2, P3, P4, TValue>> SliceDimension5()
        {
            var slices = new DataCube1<P5, DataCube4<P1, P2, P3, P4, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue5, _ => new DataCube4<P1, P2, P3, P4, TValue>());
                slice.Set(p.ExceptValue5, v);
            });
            return slices;
        }
    }

    /// <summary>
    /// A 6-dimensional data cube.
    /// </summary>
    public class DataCube6<P1, P2, P3, P4, P5, P6, TValue> : DataCube<Position6<P1, P2, P3, P4, P5, P6>, TValue>
    {
        /// <summary>
        /// Creates an empty 6-dimensional data cube. 
        /// </summary>
        public DataCube6()
        {
            Domain1Values = new HashSet<ValueTuple<P1>>();
            Domain2Values = new HashSet<ValueTuple<P2>>();
            Domain3Values = new HashSet<ValueTuple<P3>>();
            Domain4Values = new HashSet<ValueTuple<P4>>();
            Domain5Values = new HashSet<ValueTuple<P5>>();
            Domain6Values = new HashSet<ValueTuple<P6>>();
        }

        /// <summary>
        /// Positions of values in the first dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P1> Domain1
        {
            get { return Domain1Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the second dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P2> Domain2
        {
            get { return Domain2Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the third dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P3> Domain3
        {
            get { return Domain3Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the fourth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P4> Domain4
        {
            get { return Domain4Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the fifth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P5> Domain5
        {
            get { return Domain5Values.Select(v => v.Item1); }
        }

        /// <summary>
        /// Positions of values in the sixth dimension (domain of that dimension).
        /// </summary>
        public IEnumerable<P6> Domain6
        {
            get { return Domain6Values.Select(v => v.Item1); }
        }

        private HashSet<ValueTuple<P1>> Domain1Values { get; }

        private HashSet<ValueTuple<P2>> Domain2Values { get; }

        private HashSet<ValueTuple<P3>> Domain3Values { get; }

        private HashSet<ValueTuple<P4>> Domain4Values { get; }

        private HashSet<ValueTuple<P5>> Domain5Values { get; }

        private HashSet<ValueTuple<P6>> Domain6Values { get; }

        /// <summary>
        /// Returns whether the cube contains a value at the specified position.
        /// </summary>
        public bool Contains(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
        {
            return Contains(Position6.Create(p1, p2, p3, p4, p5, p6));
        }

        /// <summary>
        /// Returns value at the specified position.
        /// </summary>
        public Option<TValue> Get(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6)
        {
            return Get(Position6.Create(p1, p2, p3, p4, p5, p6));
        }

        /// <summary>
        /// Returns value at the specified position. If there is no value present, sets the position to value generated by 
        /// the <paramref name="setter"/> function and returns the newly generated value.
        /// </summary>
        public TValue GetOrElseSet(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, Func<Unit, TValue> setter)
        {
            return GetOrElseSet(Position6.Create(p1, p2, p3, p4, p5, p6), setter);
        }
        
        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public override TValue Set(Position6<P1, P2, P3, P4, P5, P6> position, TValue value)
        {
            AddDomain(Domain1Values, position.ProductValue1);
            AddDomain(Domain2Values, position.ProductValue2);
            AddDomain(Domain3Values, position.ProductValue3);
            AddDomain(Domain4Values, position.ProductValue4);
            AddDomain(Domain5Values, position.ProductValue5);
            AddDomain(Domain6Values, position.ProductValue6);
            return base.Set(position, value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, overwrites it.
        /// </summary>
        public TValue Set(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, TValue value)
        {
            return Set(Position6.Create(p1, p2, p3, p4, p5, p6), value);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, returns result of the
        /// <paramref name="otherwise"/> function which is invoked with the current value.
        /// </summary>
        public TValue SetOrElse(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, TValue value, Func<TValue, TValue> otherwise)
        {
            return SetOrElse(Position6.Create(p1, p2, p3, p4, p5, p6), value, otherwise);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, TValue value, Func<TValue, TValue, TValue> updater)
        {
            return SetOrElseUpdate(Position6.Create(p1, p2, p3, p4, p5, p6), value, updater);
        }

        /// <summary>
        /// Sets value at the specified position. If there is value already present at that position, updates it with the
        /// result of the <paramref name="updater"/> function which is given the present value and the new value.
        /// </summary>
        public TValue SetOrElseUpdate<TNewValue>(P1 p1, P2 p2, P3 p3, P4 p4, P5 p5, P6 p6, TNewValue value, Func<TNewValue, TValue> valueInitialization, Func<TValue, TNewValue, TValue> updater)
        {
            return SetOrElseUpdate<TNewValue>(Position6.Create(p1, p2, p3, p4, p5, p6), value, valueInitialization, updater);
        }

        /// <summary>
        /// For each value in the cube, invokes the specified function passing in the position and the stored value.
        /// </summary>
        public void ForEach(Action<P1, P2, P3, P4, P5, P6, TValue> a)
        {
            ForEach((p, v) => a(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, p.ProductValue6, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> Select<T>(Func<P1, P2, P3, P4, P5, P6, TValue, T> f)
        {
            return Select((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, p.ProductValue6, v));
        }

        /// <summary>
        /// Transforms each value in the cube using the specified function and returns a concatenated collection of the transformed values.
        /// </summary>
        public IReadOnlyList<T> SelectMany<T>(Func<P1, P2, P3, P4, P5, P6, TValue, IEnumerable<T>> f)
        {
            return SelectMany((p, v) => f(p.ProductValue1, p.ProductValue2, p.ProductValue3, p.ProductValue4, p.ProductValue5, p.ProductValue6, v));
        }

        /// <summary>
        /// Returns a new cube containing only the values that pass the specified predicate.
        /// </summary>
        public DataCube6<P1, P2, P3, P4, P5, P6, TValue> Where(Func<Position6<P1, P2, P3, P4, P5, P6>, TValue, bool> predicate)
        {
            return Where<DataCube6<P1, P2, P3, P4, P5, P6, TValue>>(predicate);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> Transform(Func<Position6<P1, P2, P3, P4, P5, P6>, Position0> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube0<TValue> MultiTransform(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position0>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position0, DataCube0<TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> Transform<Q1>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position1<Q1>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube1<Q1, TValue> MultiTransform<Q1>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position1<Q1>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position1<Q1>, DataCube1<Q1, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 1.
        /// All values whose position differ just in dimension 1 (their positions without dimension 1 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 1.
        /// </summary>
        public DataCube5<P2, P3, P4, P5, P6, TValue> RollUpDimension1(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue1, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 1. The slices are 5-dimensional cubes without dimension 1 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P1, DataCube5<P2, P3, P4, P5, P6, TValue>> SliceDimension1()
        {
            var slices = new DataCube1<P1, DataCube5<P2, P3, P4, P5, P6, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue1, _ => new DataCube5<P2, P3, P4, P5, P6, TValue>());
                slice.Set(p.ExceptValue1, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> Transform<Q1, Q2>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position2<Q1, Q2>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube2<Q1, Q2, TValue> MultiTransform<Q1, Q2>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position2<Q1, Q2>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position2<Q1, Q2>, DataCube2<Q1, Q2, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 2.
        /// All values whose position differ just in dimension 2 (their positions without dimension 2 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 2.
        /// </summary>
        public DataCube5<P1, P3, P4, P5, P6, TValue> RollUpDimension2(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue2, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 2. The slices are 5-dimensional cubes without dimension 2 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P2, DataCube5<P1, P3, P4, P5, P6, TValue>> SliceDimension2()
        {
            var slices = new DataCube1<P2, DataCube5<P1, P3, P4, P5, P6, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue2, _ => new DataCube5<P1, P3, P4, P5, P6, TValue>());
                slice.Set(p.ExceptValue2, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> Transform<Q1, Q2, Q3>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position3<Q1, Q2, Q3>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube3<Q1, Q2, Q3, TValue> MultiTransform<Q1, Q2, Q3>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position3<Q1, Q2, Q3>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position3<Q1, Q2, Q3>, DataCube3<Q1, Q2, Q3, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 3.
        /// All values whose position differ just in dimension 3 (their positions without dimension 3 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 3.
        /// </summary>
        public DataCube5<P1, P2, P4, P5, P6, TValue> RollUpDimension3(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue3, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 3. The slices are 5-dimensional cubes without dimension 3 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P3, DataCube5<P1, P2, P4, P5, P6, TValue>> SliceDimension3()
        {
            var slices = new DataCube1<P3, DataCube5<P1, P2, P4, P5, P6, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue3, _ => new DataCube5<P1, P2, P4, P5, P6, TValue>());
                slice.Set(p.ExceptValue3, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> Transform<Q1, Q2, Q3, Q4>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position4<Q1, Q2, Q3, Q4>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube4<Q1, Q2, Q3, Q4, TValue> MultiTransform<Q1, Q2, Q3, Q4>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position4<Q1, Q2, Q3, Q4>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position4<Q1, Q2, Q3, Q4>, DataCube4<Q1, Q2, Q3, Q4, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 4.
        /// All values whose position differ just in dimension 4 (their positions without dimension 4 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 4.
        /// </summary>
        public DataCube5<P1, P2, P3, P5, P6, TValue> RollUpDimension4(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue4, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 4. The slices are 5-dimensional cubes without dimension 4 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P4, DataCube5<P1, P2, P3, P5, P6, TValue>> SliceDimension4()
        {
            var slices = new DataCube1<P4, DataCube5<P1, P2, P3, P5, P6, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue4, _ => new DataCube5<P1, P2, P3, P5, P6, TValue>());
                slice.Set(p.ExceptValue4, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube5<Q1, Q2, Q3, Q4, Q5, TValue> Transform<Q1, Q2, Q3, Q4, Q5>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position5<Q1, Q2, Q3, Q4, Q5>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position5<Q1, Q2, Q3, Q4, Q5>, DataCube5<Q1, Q2, Q3, Q4, Q5, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube5<Q1, Q2, Q3, Q4, Q5, TValue> MultiTransform<Q1, Q2, Q3, Q4, Q5>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position5<Q1, Q2, Q3, Q4, Q5>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position5<Q1, Q2, Q3, Q4, Q5>, DataCube5<Q1, Q2, Q3, Q4, Q5, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 5.
        /// All values whose position differ just in dimension 5 (their positions without dimension 5 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 5.
        /// </summary>
        public DataCube5<P1, P2, P3, P4, P6, TValue> RollUpDimension5(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue5, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 5. The slices are 5-dimensional cubes without dimension 5 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P5, DataCube5<P1, P2, P3, P4, P6, TValue>> SliceDimension5()
        {
            var slices = new DataCube1<P5, DataCube5<P1, P2, P3, P4, P6, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue5, _ => new DataCube5<P1, P2, P3, P4, P6, TValue>());
                slice.Set(p.ExceptValue5, v);
            });
            return slices;
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into position 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube6<Q1, Q2, Q3, Q4, Q5, Q6, TValue> Transform<Q1, Q2, Q3, Q4, Q5, Q6>(Func<Position6<P1, P2, P3, P4, P5, P6>, Position6<Q1, Q2, Q3, Q4, Q5, Q6>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return Transform<Position6<Q1, Q2, Q3, Q4, Q5, Q6>, DataCube6<Q1, Q2, Q3, Q4, Q5, Q6, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current cube into a new cube. The transformation is directed by two functions. 
        /// The <paramref name="positionMapper"/> maps position of values in the current cube into positions 
        /// in the new cube. If there are multiple values in the current cube, whose positions are mapped onto 
        /// the same position in the new cube, then the <paramref name="aggregator"/> function is used to 
        /// aggregate all the colliding values into one value.
        /// </summary>
        public DataCube6<Q1, Q2, Q3, Q4, Q5, Q6, TValue> MultiTransform<Q1, Q2, Q3, Q4, Q5, Q6>(Func<Position6<P1, P2, P3, P4, P5, P6>, IEnumerable<Position6<Q1, Q2, Q3, Q4, Q5, Q6>>> positionMapper, Func<TValue, TValue, TValue> aggregator)
        {
            return MultiTransform<Position6<Q1, Q2, Q3, Q4, Q5, Q6>, DataCube6<Q1, Q2, Q3, Q4, Q5, Q6, TValue>>(positionMapper, aggregator);
        }

        /// <summary>
        /// Transforms the current 6-dimensional cube into a 5-dimensional cube by excluding the dimension 6.
        /// All values whose position differ just in dimension 6 (their positions without dimension 6 are the same) are 
        /// aggregated using the <paramref name="aggregator"/> function into one value. This value is stored into the new cube with the 
        /// position without dimension 6.
        /// </summary>
        public DataCube5<P1, P2, P3, P4, P5, TValue> RollUpDimension6(Func<TValue, TValue, TValue> aggregator)
        {
            return Transform(p => p.ExceptValue6, aggregator);
        }

        /// <summary>
        /// Slices the current cube in the dimension 6. The slices are 5-dimensional cubes without dimension 6 of
        /// the current cube. Returns a new 1-dimensional cube where the values are the slices and the positions are values in 
        /// the sliced dimension.
        /// </summary>
        public DataCube1<P6, DataCube5<P1, P2, P3, P4, P5, TValue>> SliceDimension6()
        {
            var slices = new DataCube1<P6, DataCube5<P1, P2, P3, P4, P5, TValue>>();
            ForEach((p, v) =>
            {
                var slice = slices.GetOrElseSet(p.ProductValue6, _ => new DataCube5<P1, P2, P3, P4, P5, TValue>());
                slice.Set(p.ExceptValue6, v);
            });
            return slices;
        }
    }

}